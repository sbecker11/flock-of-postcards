<!DOCTYPE html>
<html>

<head>
  <title>flock-of-cards-v0.5</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div id="left-container">
    <div id="left-column">
      <div id="canvas">
        <div id="top-gradient"></div>
        <div id="bottom-gradient"></div>
        <div id="timeline-container" class="timeline-container-left"></div>
      </div>
    </div>
    <div id="right-column">
      <div id="right-header-div">
        <!-- your resume head goes here -->
        <table cellspacing="0"
          style="color:#fff;font-family:-apple-system,sans-serif;font-size:13px;width:100%;line-height:100%">
          <tbody>
            <tr>
              <td style="border-bottom:2px solid #2f5496;vertical-align:top">
                <p><span style="font-size:30px">Shawn Becker</span></p>
                <p><strong><span style="font-size:11pt">Data Engineer / Software Developer</span></strong></p>
                <p>sbecker@alum.mit.edu &bull; 857-891-0896<br>LinkedIn.com/in/shawnbecker &bull; Lehi - Utah, USA</p>
              </td>
            </tr>
          </tbody>
        </table>
        <!-- your resume head goes here -->
      </div>
      <div id="right-content-div">
        <!-- <div id="skills" style="color:black;height:50px;width:100%;"></div> -->
      </div>
      <div id="right-footer-div">
        <p class="footnote" style="text-align:bottom;">
          create a flock-of-postcards for yourself at
          <a target="_blank" href="https://www.beckerstudio.com/">beckerstudio.com</a>"
        </p>

        <div id="debugElement"></div>
      </div>
    </div>
    <div id="bulls-eye">+</div>

    <script type="text/javascript" src="static_content/jobs/jobs.js"></script>
    <script type="text/javascript" src="static_content/media/image_paths.js"></script>
    <script>

      // @ts-nocheck

      // --------------------------------------
      // theSelected globals
      
      var theSelectedCardDiv = null;
      var theSelectedCardDivLineItem = null;

      // --------------------------------------
      // TagLink globals

      // the global set of tagLinks created while creating all .Bizcard-divs from
      // the list of all `job` objects defined in "static_content/jobs.js"
      var allTagLinks = [];
      function initAllTagLinks() {
        allTagLinks = [];
      }

      // --------------------------------------
      // Element reference globals

      const rightContentDiv = document.getElementById("right-content-div");
      const debugElement = document.getElementById("debugElement");
      const leftColumn = document.getElementById("left-column");
      const canvas = document.getElementById("canvas");
      const bottomGradient = document.getElementById("bottom-gradient");
      const timelineContainer = document.getElementById("timeline-container");
      const bulls_eye = document.getElementById("bulls-eye");

      // --------------------------------------
      // Miscellaneous globals

      const BULLET_DELIMITER = "\u2022";
      const BULLET_JOINER = ' ' + BULLET_DELIMITER + ' '

      // --------------------------------------
      // BizcardDiv globals

      // width decreases as zindex increases
      const BIZCARD_WIDTH = 200;
      const BIZCARD_INDENT = 29;

      // --------------------------------------
      // CardDiv globals

      // TO DO: tune or replace
      const ESTIMATED_NUMBER_CARD_DIVS = 159;

      // card metrics are in pixels
      const MAX_CARD_POSITION_OFFSET = 200;
      const MEAN_CARD_LEFT = 0;
      const MEAN_CARD_HEIGHT = 75;
      const MEAN_CARD_WIDTH = 100;
      const MAX_CARD_SIZE_OFFSET = 20;
      const CARD_BORDER_WIDTH = 5;

      // --------------------------------------
      // Motion parallax constants

      const PARALLAX_HZ_EXAGGERATION_FACTOR = 0.05;
      const PARALLAX_VT_EXAGGERATION_FACTOR = 0.1;

      // --------------------------------------
      // Utility functions

      const isString = (value) => (typeof value === 'string' || value instanceof String);
      const isNumber = (value) => typeof value === 'number' && !isNaN(value);
      const validateKey = (obj, key) => { if (!(key in obj)) throw new Error(`Key '${key}' not found in object`); };
      const validateString = (str) => { if (typeof str === 'undefined' || str === null || typeof str !== 'string' || str.trim().length === 0) throw new Error(`Invalid string:[${str}]`); };
      const validateHexString = hexStr => { if (typeof hexStr !== 'string' || hexStr === null || hexStr === undefined || !hexStr.startsWith('#') || !/^[0-9a-fA-F]{6}$/.test(hexStr.slice(1)) || hexStr.length !== 7) throw new Error('Hexadecimal string is invalid.'); };
      const validateIntArrayLength = (arr, length) => { if (typeof arr === 'undefined' || arr === null || !Array.isArray(arr) || arr.some(item => !Number.isInteger(item)) || (typeof length !== 'undefined' && arr.length !== length)) throw new Error('Invalid array of integers or length mismatch'); };
      const validateFloat = (num) => { if (typeof num === 'undefined' || num === null || typeof num !== 'number' || !Number.isFinite(num)) throw new Error('Invalid floating-point number'); };
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const adjustRgbBrightness = (rgb, brightness) => { validateIntArrayLength(rgb, 3); return rgb.map(channel => clamp(Math.round(channel * brightness), 0, 255)); }; // 1.0 is normal brightness
      const adjustHexBrightness = (hexStr, brightness) => { validateHexString(hexStr); validateFloat(brightness); return getHexFromRGB(adjustRgbBrightness(getRGBfromHex(`${hexStr}`), brightness)); }; // 1.0 is normal brightness
      const getHexFromRGB = rgb => { validateIntArrayLength(rgb, 3); return "#" + rgb.map(c => c.toString(16).padStart(2, "0")).join("").toLowerCase(); };
      const getRGBfromHex = hexStr => { validateHexString(hexStr); return hexStr.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i)?.slice(1).map(c => parseInt(c, 16)); };
      const toFixedPoint = (value, precision) => +value.toFixed(precision);
      const linearInterp = (x, x1, y1, x2, y2) => y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
      const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const zeroPad = (num, places) => num.toString().padStart(places, "0");
      const getHSVfromRGB = ([r, g, b]) => {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const delta = max - min;
        const s = max !== 0 ? delta / max : 0;
        let h = max === min ? 0 : (max === r ? (g - b) / delta + (g < b ? 6 : 0) : max === g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        if (isNaN(h))
          h = 0;
        return [h, s, max];
      };
      const getRGBfromHSV = ([h, s, v]) => {
        const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)].map(Math.round);
      };

      // --------------------------------------
      // Javascript hacks

      // const left = getOffset(element).left; 
      // const {top,left} = getOffset(element); 
      function getOffset(el) {
        var _x = 0;
        var _y = 0;
        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
          _x += el.offsetLeft - el.scrollLeft;
          _y += el.offsetTop - el.scrollTop;
          el = el.offsetParent;
        }
        return { top: _y, left: _x };
      }

      // return "ABC" given "(apples),  !bananas#, & ~cherries"
      function acronym(text) {
        var acro = "";
        text = text.replace(/[.,\/#!@$%\^&\*;:{}=\-_`~()]/g, "").toUpperCase();
        var parts = text.trim().split(" ");
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i].trim()
          if (part.length > 0) {
            // add first char
            acro += part[0];
          }
        }
        if (acro.length == 0)
          acro = text.slice(0, Math.min(3, text.length));
        return acro;
      }



      // --------------------------------------
      // Z globals

      // ground is zindex = 0 and zindex is offset from ground,
      // and z is distance to viewer, so 
      // z = MAX_Z - zindex,
      // conversely 
      // zindex = MAX_Z - z.
      const ALL_CARDS_MAX_Z = 15;
      const BIZCARD_MAX_Z = 14;
      const BIZCARD_MIN_Z = 12;
      const CARD_MAX_Z = 8;
      const CARD_MIN_Z = 1;
      const ALL_CARDS_MIN_Z = 1;

      // brightness decreases to MIN_BRIGHTNESS_PERCENT as z increases
      const MIN_BRIGHTNESS_PERCENT = 75;

      // card blur increases as z increases
      const BLUR_Z_SCALE_FACTOR = 4;


      //--------------------------------------
      // Z functions

      function get_zindexStr_from_z(z) {
        return `${ALL_CARDS_MAX_Z - z}`;
      }
      function get_z_from_zIndexStr(zindex) {
        return ALL_CARDS_MAX_Z - parseInt(zindex);
      }
      // brightness max CARD_MIN_Z is 1.0 is normal
      // brightness dims as z increated to CARD_MAX_Z
      function get_brightness_value_from_z(z) {
        var z_brightness_value = linearInterp(
          z,
          CARD_MIN_Z, 1.0,
          CARD_MAX_Z, MIN_BRIGHTNESS_PERCENT / 100.0
        );
        return z_brightness_value;
      }
      // return a filter brightness string
      // brightness dims as z increases
      function get_brightness_str_from_z(z) {
        return `brightness(${100 * get_brightness_value_from_z(z)}%)`;
      }
      // returns a filter blur string
      // blur increases as z increases
      function get_blur_str_from_z(z) {
        var blur = (z - CARD_MIN_Z) / BLUR_Z_SCALE_FACTOR;
        return `blur(${blur}px)`;
      }

      // returns a filter string of the form:
      // "brightness(<_brightness>%) blur(<blur>px)"
      function get_filterStr_from_z(z) {
        var filterStr = "";
        filterStr += get_brightness_str_from_z(z) + " ";
        filterStr += get_blur_str_from_z(z);
        return filterStr;
      }

      // --------------------------------------
      // TimeLine globals

      // the global set of all yearDivBottoms created 
      // from TIMELINE_MAX_YEAR down to TIMELINE_MIN_YEAR
      var timelineYearDivBottoms = {};
      function inittimelineYearDivBottoms() {
        timelineYearDivBottoms = {}
      }

      const TIMELINE_DEFAULT_YEAR = 2007;
      const TIMELINE_MAX_YEAR = 2023;
      const TIMELINE_MIN_YEAR = 1977;

      // YEAR dimensions are in px
      const YEAR_BOTTOM_TO_BOTTOM = 162;
      const YEARDIV_FONTSIZE = 48;
      const MONTHTICK_FONTSIZE = 9;

      // --------------------------------------
      // Timeline functions 
      // --------------------------------------

      // used to get canvas-relative top position for anything 
      // take care to always append "px" for pixels
      function getTimelineYearMonthBottom(yearStr, monthStr) {
        var month = parseInt(monthStr, 10);
        return timelineYearDivBottoms[yearStr] - (month - 1) * YEAR_BOTTOM_TO_BOTTOM / 12;
      }

      // the total height of the timeline in pixels
      // take care to always append "px" for pixels
      function getTimelineHeight() {
        return getTimelineYearMonthBottom(TIMELINE_MIN_YEAR, 1);
      }

      // append year-divs and year-dashes into timeline-container
      function createTimeline() {
        inittimelineYearDivBottoms();

        var alignment = timelineContainer.classList.contains("timeline-container-left") ? "left" : "right";

        for (var year = TIMELINE_MAX_YEAR; year >= TIMELINE_MIN_YEAR; year--) {
          var yearDiv = document.createElement("div");
          yearDiv.classList.add("year-div");

          if (alignment == "left") {
            yearDiv.classList.add("year-div-left");
            yearDiv.innerHTML = `&nbsp;${year}`;
          }
          else {
            yearDiv.classList.add("year-div-right");
            yearDiv.innerHTML = `${year}&nbsp;`;
          }

          var row = TIMELINE_MAX_YEAR - year;
          var yearDivBottom = (row + 1) * YEAR_BOTTOM_TO_BOTTOM;
          timelineYearDivBottoms[`${year}`] = yearDivBottom;

          yearDiv.style.fontSize = `${YEARDIV_FONTSIZE}px`;
          yearDiv.style.height = `${YEARDIV_FONTSIZE}px`;
          yearDiv.style.bottom = `${yearDivBottom}px`;
          yearDiv.style.top = `${yearDivBottom - YEARDIV_FONTSIZE}px`;
          timelineContainer.appendChild(yearDiv);

          for (var month = 1; month <= 12; month++) {
            var monthTick = document.createElement("div");
            monthTick.classList.add("month-tick");
            if (alignment == "left")
              monthTick.classList.add("month-tick-left");
            else
              monthTick.classList.add("month-tick-right");
            var monthStr = zeroPad(month, 2);
            var monthTickBottom = getTimelineYearMonthBottom(year, monthStr);
            var check = yearDivBottom - (month - 1) * YEAR_BOTTOM_TO_BOTTOM / 12;
            if (monthTickBottom != check)
              console.log(`WARNING: monthTickBottom:${monthTickBottom} != check:${check}`);
            if (getTimelineYearMonthBottom(year, "01") != timelineYearDivBottoms[`${year}`])
              console.log("WARNING: year-01 != year");

            monthTick.style.fontSize = `${MONTHTICK_FONTSIZE}px`;
            monthTick.style.height = `${MONTHTICK_FONTSIZE}px`;
            monthTick.style.bottom = `${monthTickBottom}px`;
            monthTick.style.top = `${monthTickBottom - MONTHTICK_FONTSIZE}px`;
            monthTick.innerHTML = `${year}-${monthStr}`;
            timelineContainer.appendChild(monthTick);
          }
        }
      }

      // --------------------------------------
      // BizcardDiv and cardDiv functions

      function isBizcardDiv(cardDiv) {
        return cardDiv.classList.contains('bizcard-div') ? true : false;
      }
      function isCardDiv(cardDiv) {
        return cardDiv.classList.contains('card-div') ? true : false;
      }
      function isBizcardDivId(cardDivId) {
        return getBizcardDivIndex(cardDivId) == null ? false : true;
      }
      function isCardDivId(cardDivId) {
        return getCardDivIndex(cardDivId) == null ? false : true;
      }
      // returns 99 for bizcard-div-99' or null
      function getBizcardDivIndex(cardDivId) {
        console.assert( isString(divCardId) );
        if (cardDivId.startsWith("bizcard-div-")) {
          var index = parseInt(cardDivId.replace("bizcard-div-", ""));
          return isNaN(index) ? null : index;
        }
        return null;
      }

      // returns 99 for 'card-div-99' or null
      function getCardDivIndex(cardDivId) {
        console.assert( isString(cardDivId) );
        if (cardDivId.startsWith("card-div-")) {
          var index = parseInt(cardDivId.replace("card-div-", ""));
          return isNaN(index) ? null : index;
        }
        return null;
      }

      // returns true if a bizcardDiv exists for the given index, else null
      function getBizcardDivIdFromIndex(index) {
        console.assert(isNumber(index) );
        var bizcardDivId = `bizcard-div-${index}`;
        var bizcardDiv = document.getElementById(bizcardDivId);
        return (bizcardDiv && bizcardDiv.id == bizcardDivId) ? bizcardDivId : null;
      }

      // .Bizcard-divs are never deleted so next id
      // is just the current number of the .Bizcard-divs
      function getNextBizcardDivId() {
        const bizcardDivs = document.getElementsByClassName("bizcard-div");
        const nextBizcardDivId = `bizcard-div-${bizcardDivs.length}`;
        return nextBizcardDivId;
      }

      // returns 23 for "bizcard-div-23"
      function getBizcardDivIndex(bizcardDivId) {
        if (isString(bizcardDivId)) {
          var index = parseInt(bizcardDivId.replace("bizcard-div-", ""));
          return isNumber(index) ? index : null;
        }
        return null;
      }


      // Use the "jobs" array to gather data used for
      // the large "business cards" floating near 
      // the ground level describing employment history.
      //
      // Also parse each job's description to pull out 
      // the shared "skills" from the narrative pf each.
      //  
      function createBizcardDivs() {
        var num_valid_rows = 0;
        for (let i = 0; i < jobs.length; i++) {
          var job = jobs[i];
          var role = job["role"];
          validateString(role);
          var employer = job["employer"].trim();
          validateString(employer);
          var css_hex_background_color_str = job["css RGB"].trim();
          validateHexString(css_hex_background_color_str);
          validateKey(job, "text color");
          var font_color_name = job["text color"].trim();
          validateString(font_color_name);

          // timeline is descending so jobEnd is always above jobStart
          var jobEnd = job["end"].trim().replace("-01", "");
          validateString(jobEnd);
          var endYearStr = jobEnd.split("-")[0];
          validateString(endYearStr);
          var endMonthStr = jobEnd.split("-")[1];
          validateString(endMonthStr);
          var endBottomPx = getTimelineYearMonthBottom(endYearStr, endMonthStr);

          var jobStart = job["start"].trim().replace("-01", "");
          validateString(jobStart);
          var startYearStr = jobStart.split("-")[0];
          validateString(startYearStr);
          var startMonthStr = jobStart.split("-")[1];
          validateString(startMonthStr);
          var startBottomPx = getTimelineYearMonthBottom(startYearStr, startMonthStr);

          var heightPx = startBottomPx - endBottomPx;
          var zIndexStr = job["z-index"];
          var zIndex = parseInt(zIndexStr);
          var z = get_z_from_zIndexStr(zIndexStr);
          var indent = (zIndex - 1) * BIZCARD_INDENT;

          // here we go
          var bizcardDiv = document.createElement("div");
          console.assert(bizcardDiv != null);
          var top = endBottomPx;
          var height = heightPx;
          var left = indent;
          var width = BIZCARD_WIDTH;

          bizcardDiv.id = getNextBizcardDivId();
          bizcardDiv.classList.add("bizcard-div");
          bizcardDiv.style.top = `${top}px`;
          bizcardDiv.style.height = `${height}px`;
          bizcardDiv.style.left = `${left}px`;
          bizcardDiv.style.width = `${width}px`;
          bizcardDiv.style.zIndex = zIndexStr;

          // save the original center 
          var originalCtrX = left + width / 2;
          var originalCtrY = top + height / 2;
          var originalZ = z;
          bizcardDiv.setAttribute("originalCtrX", `${originalCtrX}`);
          bizcardDiv.setAttribute("originalCtrY", `${originalCtrY}`);
          bizcardDiv.setAttribute("originalZ", `${originalZ}`);

          bizcardDiv.setAttribute("saved-background-color", css_hex_background_color_str);
          bizcardDiv.setAttribute("saved-color", font_color_name);
          bizcardDiv.setAttribute("saved-selected-background-color", adjustHexBrightness(css_hex_background_color_str, 1.7));
          bizcardDiv.setAttribute("saved-selected-color", font_color_name);

          var description_HTML = job["Description"];
          if (description_HTML && description_HTML.length > 0) {
            validateString(description_HTML);
            // description.replace("â€¢","<br/j>*");
            description_HTML = process_bizcard_description_HTML(bizcardDiv, description_HTML);
            bizcardDiv.setAttribute("Description", description_HTML);
          }

          bizcardDiv.setAttribute("saved-zIndexStr", zIndexStr);
          bizcardDiv.setAttribute("saved-filterStr", get_filterStr_from_z(z));

          bizcardDiv.style.zIndex = bizcardDiv.getAttribute("saved-zIndexStr") || "";
          bizcardDiv.style.filter = bizcardDiv.getAttribute("saved-filterStr") || "";
          bizcardDiv.style.backgroundColor = bizcardDiv.getAttribute("saved-background-color") || "";
          bizcardDiv.style.color = bizcardDiv.getAttribute("saved-color") || "";

          var html = "";
          html += `<span class="bizcard-div-role">${role}</span><br/>`;
          html += `(${bizcardDiv.id})<br/>`;
          html += `<span class="bizcard-div-employer">${employer}</span><br/>`;
          html += `<span class="bizcard-div-dates">${jobStart} - ${jobEnd}</span><br/>`;
          bizcardDiv.innerHTML = html;

          bizcardDiv.addEventListener("mouseenter", handleCardDivMouseEnter);
          bizcardDiv.addEventListener("mouseleave", handleCardDivMouseLeave);

          addCardDivClickListener(bizcardDiv);
          // does not select self
          // does not scroll self into view

          canvas.appendChild(bizcardDiv);

          num_valid_rows++;
        }
        // renderAllTranslateableDivsAtLeftColumnCenter();
      }

      // Use the BULLET_DELIMITER point character as separator to split the
      // `bizcard_description` into a list of `description_items`.
      //
      // Parse each description_item to find the pattern `[skill_phrase](skill_img_url)`.
      // Finds or creates a `card-div` for each `skill_phrase` and replaces the 
      // original html with 
      //    `<card-link card-div-id="id" card-img-url="url">skill</card-link>`
      // The `card-img-url` is ignored if its value if "url" or blank.
      //
      // Uses the BULLET_DELIMITER separator to join the list of description_items 
      // back into an updated HTML description so it can be used to create an ordered 
      // list with list items.
      //
      function process_bizcard_description_HTML(bizcardDiv, description_HTML) {
        console.assert(bizcardDiv != null);
        var processed_items = [];
        var description_items = description_HTML.split();
        if (description_items.length > 0) {
          for (var i = 0; i < description_items.length; i++) {
            var description_item = description_items[i].trim();
            if (description_item.length > 0) {
              var { newTagLinks, updatedString } = process_bizcard_description_item(bizcardDiv, description_item);
              if (updatedString && updatedString.length > 0)
                processed_items.push(updatedString);
              if (newTagLinks && newTagLinks.length > 0)
                // update the global list of allTagLinks 
                // created from description_HTML of all .Bizcard-divs
                allTagLinks = allTagLinks.concat(newTagLinks);
            }
          }
        }
        var processed_bizcard_description_HTML = description_HTML;
        if (processed_items.length > 0)
          processed_bizcard_description_HTML = processed_items.join(BULLET_JOINER);
        return processed_bizcard_description_HTML;
      }

      function process_bizcard_description_item(bizcardDiv, inputString) {
        console.assert(bizcardDiv != null);
        const tagRegex = /\[(.*?)\]\((.*?)\)/g;
        const newTagLinks = [];
        const updatedString = inputString.replace(tagRegex, function (match, text, url) {
          const tagLink = { text, url };
          addCardDivId(bizcardDiv, tagLink);
          newTagLinks.push(tagLink);
          const cardDivId = tagLink['cardDivId'];
          const spanId = `tagLink-${cardDivId}`;
          const tagLinkImgUrl = url;
          const tagLinkHtml = text;
          return `<span id="${spanId}" class="tagLink" targetCardDivId="${cardDivId}">${tagLinkHtml}</span>`;
        });
        return { newTagLinks, updatedString };
      }

      // find or create a cardDiv and use it
      // to set the tagLink's "cardDivId" property
      function addCardDivId(bizcardDiv, tagLink) {
        console.assert(bizcardDiv != null && tagLink != null);
        var cardDiv = findCardDiv(tagLink);
        if (!cardDiv) {
          cardDiv = createCardDiv(bizcardDiv, tagLink);
        }
        tagLink['cardDivId'] = cardDiv.id;
      }

      // this is an Order(N) search that could be optimized.
      function findCardDiv(tagLink) {
        var cardDivs = document.getElementsByClassName("card-div");
        for (var i = 0; i < cardDivs.length; i++) {
          var cardDiv = cardDivs[i];
          if (cardDivMatchesTagLink(cardDiv, tagLink))
            return cardDiv;
        }
        return null;
      }

      function cardDivMatchesTagLink(cardDiv, tagLink) {
        if (cardDiv.getAttribute("tagLinkText") != tagLink["text"])
          return false;
        if (cardDiv.getAttribute("tagLinkUrl") != tagLink["url"])
          return false;
        return true;
      }

      // takes the description_HTML stored as innerHTML
      // of a card-div (or bizcard-div) and splits it by
      // the BULLLET delimiter and returns the HTML of an 
      // unordered list of description items.
      function convert_description_HTML_to_line_items_HTML(description_HTML) {
        var HTML = "";
        HTML += '<p class="card-div-line-item-description">';
        var items = description_HTML.split(BULLET_DELIMITER);
        if (items.length > 0) {
          HTML += '<ul class="card-div-line-item-description-list">';
          for (var i = 0; i < items.length; i++) {
            var description_item = items[i].trim();
            if (description_item.length > 0)
              HTML += "<li class='card-div-line-item-description-list-item'>" + description_item + "</li>";
          }
          HTML += "</ul>"
        } else {
          console.log(`unparsed description: ${description_HTML}`);
          HTML += description_HTML;
        }
        HTML += "</p>"
        return HTML;
      }

      // --------------------------------------
      // CardDiv functions

      // card-divs are never deleted so next id
      // is just the current number of the card-divs
      function getNextCardDivId() {
        const cardDivs = document.getElementsByClassName("card-div");
        const nextCardDivId = `card-div-${cardDivs.length}`;
        return nextCardDivId;
      }

      var prev_z = null; // to track the previous z value

      // adds a new cardDivs to #canvas
      // default center x to zero and center y to
      // id * TOP_TO_TOP.
      // give each random x,y offsets and random
      // z levels, and z-varied brightness and blur.
      // return the newly created cardDiv that has 
      // been appended to its parent canvas.
      function createCardDiv(bizcardDiv, tagLink) {
        console.assert(bizcardDiv != null && tagLink != null);
        var cardDivId = getNextCardDivId();
        var cardDiv = document.createElement('div');
        cardDiv.classList.add("card-div");
        cardDiv.id = cardDivId;
        canvas.appendChild(cardDiv);

        const cardDivIndex = getCardDivIndex(cardDivId) || 0;
        const total_vt_distance = getTimelineHeight();
        const vt_top_to_top = total_vt_distance / ESTIMATED_NUMBER_CARD_DIVS;
        const vt_top = cardDivIndex * vt_top_to_top - vt_top_to_top / 2;

        // card-div tops can be UNIFORMLY REDISTRIBUTED
        // and given random offsets after all card-divs 
        // have been created
        const verticalOffset = getRandomInt(-MAX_CARD_POSITION_OFFSET, MAX_CARD_POSITION_OFFSET);
        var top = vt_top + verticalOffset
        cardDiv.style.top = `${top}px`;

        const horizontalOffset = getRandomInt(-MAX_CARD_POSITION_OFFSET, MAX_CARD_POSITION_OFFSET);
        var left = MEAN_CARD_LEFT + horizontalOffset;
        cardDiv.style.left = `${left}px`;

        var z = getRandomInt(CARD_MIN_Z, CARD_MAX_Z);
        while (z === prev_z) {
          // Generate a new z if it's the same as the previous one
          z = getRandomInt(CARD_MIN_Z, CARD_MAX_Z);
        }
        prev_z = z;

        var zIndexStr = get_zindexStr_from_z(z);

        // inherit colors of bizcardDiv
        cardDiv.setAttribute("bizcardDivId", bizcardDiv.id);
        copyAttributes(cardDiv, bizcardDiv, [
          'saved-background-color',
          'saved-color',
          'saved-selected-background-color',
          'saved-selected-color']);

        cardDiv.setAttribute("saved-zIndexStr", zIndexStr);
        cardDiv.setAttribute("saved-filterStr", get_filterStr_from_z(z));

        cardDiv.style.zIndex = cardDiv.getAttribute("saved-zIndexStr") || "";
        cardDiv.style.filter = cardDiv.getAttribute("saved-filterStr") || "";
        cardDiv.style.backgroundColor = cardDiv.getAttribute("saved-background-color") || "";
        cardDiv.style.color = cardDiv.getAttribute("saved-color") || "";

        // the tagLink is used to define the contents of this cardDiv
        const tagLinkImgUrl = tagLink['url'];
        const tagLinkHtml = tagLink['text'];
        const spanId = `tagLink-${cardDivId}`;
        cardDiv.innerHTML = `<span id="${spanId}" class="tagLink" targetCardDivId="${cardDivId}">${tagLinkHtml}<br/>(${cardDivId})</span>`;

        // ==================================================================
        // divCard img_src and dimensions

        var img_src = null;
        var img_width = MEAN_CARD_WIDTH;
        var img_height = MEAN_CARD_HEIGHT;

        // given a tagLinkImgUrl try to get the real img_src and dimensions of the actual image
        var result = get_real_img_src_from_img_url(tagLinkImgUrl);
        if (result) {
          const { real_img_src, real_img_width, real_img_height } = result;
          img_src = real_img_src;
          img_width = real_img_width;
          img_height = real_img_height;
        }

        // try to select a random image path
        // if ( !img_src ) {
        //   var result = select_random_img_src();
        //   if ( result ) {
        //     const { random_img_src, random_img_width, random_img_height} = result;
        //     img_src = random_img_src;
        //     img_width = random_img_width;
        //     img_height = random_img_height;
        //   }
        // }

        // just generate a random img_src using a random img_width and img_height
        // if( !img_src ) {
        //   img_width = MEAN_CARD_WIDTH + getRandomInt(-MAX_CARD_SIZE_OFFSET,MAX_CARD_SIZE_OFFSET);
        //   img_height = MEAN_CARD_HEIGHT + getRandomInt(-MAX_CARD_SIZE_OFFSET,MAX_CARD_SIZE_OFFSET);
        //   img_src = `https://picsum.photos/${img_width}/${img_height}`;
        // }

        var width = img_width + 2 * CARD_BORDER_WIDTH;
        var height = img_height + 2 * CARD_BORDER_WIDTH
        cardDiv.style.borderWidth = `${CARD_BORDER_WIDTH}px`;
        cardDiv.style.borderStyle = "solid";
        cardDiv.style.borderColor = "white";
        cardDiv.style.width = `${width}px`;
        cardDiv.style.height = `${height}px`;

        // save the original center 
        var originalCtrX = left + width / 2;
        var originalCtrY = top + height / 2;
        var originalZ = z;
        cardDiv.setAttribute("originalCtrX", `${originalCtrX}`);
        cardDiv.setAttribute("originalCtrY", `${originalCtrY}`);
        cardDiv.setAttribute("originalZ", `${originalZ}`);

        if (img_src !== null) {
          var img = document.createElement("img");
          img.classList.add("card-div-img");
          img.id = "card-div-img-" + cardDivId;
          img.src = img_src;
          img.style.width = `${img_width}px`;
          img.style.height = `${img_height}px`;
          img.alt = cardDiv.id;
          cardDiv.appendChild(img);
        }

        cardDiv.addEventListener("mouseenter", handleCardDivMouseEnter);
        cardDiv.addEventListener("mouseleave", handleCardDivMouseLeave);

        addCardDivClickListener(cardDiv);
        // does not select self
        // does not scroll self into view

        renderAllTranslateableDivsAtLeftColumnCenter();

        cardDiv.setAttribute("tagLinkText", tagLink["text"]);
        cardDiv.setAttribute("tagLinkUrl", tagLink["url"]);
        return cardDiv;
      }

      function copyAttributes(dstDiv, srcDiv, attrs) {
        console.assert(dstDiv != null && srcDiv != null && attrs != null);
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var srcVal = srcDiv.getAttribute(attr);
          console.assert(isString(srcVal),  `attr:${attr} src:${srcVal}`);
          dstDiv.setAttribute(attr, srcVal);
          var dstVal = dstDiv.getAttribute(attr);
          console.assert(dstVal == srcVal, `attr:${attr} dst:${dstVal} != src:${srcVal}`);
        }
      }

      // returns the number of attribute value differences 
      function diffAttributes(dstDiv, srcDiv, attrs) {
        var numErrors = 0;
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          var dstVal = dstDiv.getAttribute(attr);
          var srcVal = srcDiv.getAttribute(attr);
          if (dstVal = srcVal) {
            console.log(`attr:${attr} dst:${dstVal} != src:${srcVal}`);
            numErrors += 1;
          }
        }
        return numErrors;
      }

      function animateCardDivTowardsBizcardDiv(cardDivId, bizcardDivId) {
        var cardDiv = document.getElementById(cardDivId);
        var bizcardDiv = document.getElementById(bizcardDivId);

        var cardOriginalCtrX = parseInt(cardDiv.getAttribute("originalCtrX") || "0");
        var cardOriginalCtrY = parseInt(cardDiv.getAttribute("originalCtrY") || "0");
        var cardOriginalZ = parseInt(cardDiv.getAttribute("originalZ") || "0");

        var bizcardOriginalCtrX = parseInt(bizcardDiv.getAttribute("originalCtrX") || "0");
        var bizcardOriginalCtrY = parseInt(bizcardDiv.getAttribute("originalCtrY") || "0");
        var bizcardOriginalZ = parseInt(bizcardDiv.getAttribute("originalZ") || "0");

        var deltaX = bizcardOriginalCtrX - cardOriginalCtrX;
        var deltaY = bizcardOriginalCtrY - cardOriginalCtrY;
      }

      function animateCardDivToOriginalPosition(cardDivId) {
        var cardDiv = document.getElementById(cardDivId);
        var originalTop = parseInt(cardDiv.getAttribute("originalTop") || "0");
        var originalLeft = parseInt(cardDiv.getAttribute("originalLeft") || "0");
        var originalZ = parseInt(cardDiv.getAttribute("originalZ") || "0");

      }

      // these are used by select_random_img_src
      var selected_image_paths = [];
      var invalid_image_paths = [];

      // returns { image_src, width, height } or null
      function select_random_img_src() {

        // immedately return null if image_paths are not available
        if ((typeof image_paths === 'undefined') ||
          (image_paths == null) ||
          (image_paths.length == 0)) {
          return null;
        }

        if (selected_image_paths.length + invalid_image_paths.length === image_paths.length) {
          return null; // All image paths have been selected or marked as invalid
        }
        while (true) {
          const randomIndex = Math.floor(Math.random() * image_paths.length);
          const filePath = image_paths[randomIndex];

          if (!selected_image_paths.includes(filePath) && !invalid_image_paths.includes(filePath)) {
            const filename = filePath.split('/').pop();
            const regex = /^(.*?)-(\d+)x(\d+)\.(\w+)$/;
            const match = filename.match(regex);
            if (!match) {
              console.log(`Invalid filename format: ${filename}`);
              invalid_image_paths.push(filePath);
              continue;
            }
            const name = match[1];
            const random_img_width = parseInt(match[2]);
            const random_img_height = parseInt(match[3]);
            const extension = match[4];
            selected_image_paths.push(filePath);
            const random_img_src = filePath;
            return { random_img_src, random_img_width, random_img_height };
          }
        }
      }

      // Given an img_url returns null if its format is invalid
      // of if an actual image file cannot be loaded using that url.
      // Otherwise returns an object with real values
      // 
      function get_real_img_src_from_img_url(img_url) {
        // return { real_img_src, real_img_width, real_img_height };
        return null;
      }

      /**
       * Summary. Returns the translate string used to transform
       * any cardDiv's x,y coordinates into canvas-relative coordinates.
       * this assortment of divs has only a fixed number of possible
       * z values so the results of this function are cashed for
       * speed of access.
       *
       * Description. (use period)
       * @param {number}  dh           the horizontal parallax offset value
       * @param {number}  dv           the vertical parallax offet value
       * @param {number}    z            the random Z depth assigned to every cardDiv
       *                              where z ranges from 1 as max dist to viewer
       *                              to ALL_CARDS_MAX_Z being closest to viewer
       *                              with an integer value between CARD_MIN_Z and CARD_MAX_Z
       * @param {number}  leftColumn_dx    the x value used to convert cardDiv.x to leftColumn-relative position
       * @param {number}  leftColumn_dy    the y value used to convert cardDiv.y to leftColumn-relative position
       *
       * @return {string} Return a string with format "12.02px -156.79px"
       */
      function getZTranslateStr(dh, dv, z, leftColumn_dx, leftColumn_dy) {
        // z ranges from 0 (closest) to viewer to MAX_Z furthest from viewer
        // zindex ranges MAX_Z (closest to viewer) to 1 furthest from viewer
        var zindex = get_zindexStr_from_z(z);
        var zScale = z * 1.0;

        // by definition, divs have zero mean hzCtrs so canvas translation is required
        var dx = dh * zScale + leftColumn_dx;
        var dy = dv * zScale + 0; // leftColumn_dy;
        var zTranslateStr = `${dx}px ${dy}px`;

        return zTranslateStr;
      }

      function getElementCtr(element) {
        var hzCtr = (element.offsetLeft + element.offsetWidth) / 2;
        var vtCtr = (element.offsetTop + element.offsetHeight) / 2;
        return { hzCtr: hzCtr, vtCtr: vtCtr };
      }

      // return the horizontal center of the left-column
      function getLeftColumnHzCtr() {
        return leftColumn.offsetWidth / 2;
      }
      // return the vertical center of the left-column
      function getLeftColumnVtCtr() {
        return leftColumn.offsetHeight / 2;
      }
      // return the horizontal center of the given element relative to itself
      function getElementSelfHzCtr(element) {
        return element.offsetWidth / 2;
      }
      // return the vertical center of the given element relative to itself
      function getElementSelfVtCtr(element) {
        return element.offsetHeight / 2;
      }


      // return all bizcardDivs and cardDivs lazy-loaded
      function getAllTranslateableCardDivs() {
        var allDivs = [];
        allDivs = Array.prototype.concat.apply(
          allDivs,
          canvas.getElementsByClassName("bizcard-div")
        );
        allDivs = Array.prototype.concat.apply(
          allDivs,
          canvas.getElementsByClassName("card-div")
        );
        return allDivs;
      }

      // applies z-depth scaled parallax to all translateableDiv
      function applyMotionParallax(parallax_dh, parallax_dv) {

        // constant for the current view
        var leftColumnHzCtr = getLeftColumnHzCtr();
        var leftColumnVtCtr = getLeftColumnVtCtr();

        // constants for this parallax
        var dh = parallax_dh * PARALLAX_HZ_EXAGGERATION_FACTOR;
        var dv = parallax_dv * PARALLAX_VT_EXAGGERATION_FACTOR;

        // compute and apply translations for all translatableDivs
        var allDivs = getAllTranslateableCardDivs();
        for (var i = 0; i < allDivs.length; i++) {
          var cardDiv = allDivs[i];

          var zIndexStr = cardDiv.style.zIndex;

          var z = get_z_from_zIndexStr(zIndexStr);

          // leftColumn-relative cardDiv center
          var leftColumn_dx = leftColumnHzCtr - getElementSelfHzCtr(cardDiv);
          var leftColumn_dy = leftColumnVtCtr - getElementSelfVtCtr(cardDiv);

          var zTranslateStr = getZTranslateStr(dh, dv, z, leftColumn_dx, leftColumn_dy);

          try {
            cardDiv.style.translate = zTranslateStr;
          } catch (error) {
            console.error(`applyParallax cardDiv:${cardDiv.id}`, error);
          }
        }
      }

      var scrollingInterval = null;
      var autoscrollVelocity = 0;

      const smoothingFactors = [0, 10.0, 0.2, 0.3]; // Adjust smoothing factors for each degree of interpolation


      // Function to handle transform cardDivs according
      // to current left-column position. Given null
      // when called from onload, in this case
      // left-column center as mouse location

      function handleLeftColumnMouseMove(event) {

        var rect = leftColumn.getBoundingClientRect();
        var centerX = rect.left + rect.width / 2;
        var centerY = rect.top + rect.height / 2;

        var mouseX = centerX;
        var mouseY = centerY;
        if (event) {
          mouseX = event.clientX;
          mouseY = event.clientY;
        }

        var dist_v = mouseY - centerY;
        var delta_vt = ((mouseY - centerY) / centerY) * 100;
        var parallax_dh = 0;
        var parallax_dv = 0;
        var autoscrollVelocity = 0;

        // normal mouse-driven parallax
        if (Math.abs(delta_vt) < 50) {
          parallax_dh = centerX - mouseX;
          parallax_dv = centerY - mouseY;
        } else {
          // maximum vertical auto-scroll velocity
          const MAX_SCROLL_VT = 10.0;

          // start to scroll when mouse is > 50% of distance
          // from center  to top or bottom edge of viewport
          // autoscrollVelocity is zero at 50% of distance from
          // center. autoscrollVelocity speeds up linearly
          // to MAX_SCROLL_VT when mouseX reaches the top
          // or bottom edge of the viewport, in other words,
          // where |mouseY - centerY| == |centerY - topEdge (0)|
          if (Math.abs(delta_vt) >= 50) {
            var delta_vt_normalized = Math.abs(delta_vt) - 50;
            autoscrollVelocity = (delta_vt_normalized / 50) * MAX_SCROLL_VT;
            autoscrollVelocity = delta_vt > 0 ? autoscrollVelocity : -autoscrollVelocity;
          }

          clearInterval(scrollingInterval);

          if (Math.abs(autoscrollVelocity) > 0.01) {
            // use autoscrollVelocity to
            // auto-scroll left-column from currentScrollTop
            // to newScrollTop = currentScrollTop + autoscrollVelocity pixels
            // in 10 millis
            scrollingInterval = setInterval(function () {
              var currentScrollTop = leftColumn.scrollTop;
              var newScrollTop = currentScrollTop + autoscrollVelocity;

              if (newScrollTop < 0) {
                newScrollTop = 0;
              } else {
                var maxScrollTop =
                  leftColumn.scrollHeight - leftColumn.clientHeight;
                if (newScrollTop > maxScrollTop) {
                  newScrollTop = maxScrollTop;
                }
              }

              // apply the change and
              // then wait for 10 millis
              leftColumn.scrollTop = newScrollTop;
            }, 10);
          }

          parallax_dh = centerX - mouseX;
          parallax_dv = -(dist_v + autoscrollVelocity);

        }
        applyMotionParallax(parallax_dh, parallax_dv);
      }

      function debugScrolling(event, scrollable, scrollVelocityType, scrollVelocity) {
        var scrollTop = scrollable.scrollTop;
        var scrollHeight = scrollable.scrollHeight;
        var windowHeight = scrollable.clientHeight;
        var scrollBottom = scrollHeight - scrollTop - windowHeight;

        var html = "";
        html += `event:${event}<br/>`;
        html += `scrollTop:${scrollTop}<br/>`;
        html += `scrollBottom:${scrollBottom}<br/>`;
        if (scrollVelocityType != null && scrollVelocity != null)
          html += `${scrollVelocityType}:${scrollVelocity}<br/>`;

        debugElement.innerHTML = html;
      }

      // Display mouse position and delta coordinates in the right-message-div  
      var isMouseOverLeftColumn = false;

      function handleMouseEnterLeftColumn() {
        isMouseOverLeftColumn = true;
      }

      // stop scrolling when mouse is no longer over the left column
      function handleMouseLeaveLeftColumn() {
        isMouseOverLeftColumn = false;
        clearInterval(scrollingInterval);
        autoscrollVelocity = 0;
        //debugElement.innerHTML = "";
      }

      var lastScrollTop = null;
      var lastScrollTime = null;

      function handleLeftColumnScroll(scrollEvent) {
        var thisTime = (new Date()).getTime();
        var thisScrollTop = leftColumn.scrollTop;
        var deltaTime = (lastScrollTime != null) ? (thisTime - lastScrollTime) : null;
        var deltaTop = (lastScrollTop != null) ? (thisScrollTop - lastScrollTop) : null;
        var scrollVelocity = (deltaTime && deltaTop) ? (deltaTop) / (deltaTime) : "?";
        debugScrolling("scroll", leftColumn, "scrollVelocity", `${deltaTop}/${deltaTime}`);
        lastScrollTime = thisTime;
        lastScrollTop = thisScrollTop;
      }

      // calculates dh,dv parallax when
      // mouse wheel is moving
      // leftColumn_wheel_dh ==  leftColumn_mouse_dh
      // leftColumn_wheel_dv ==  leftColumn_mouse_dv
      // when mouse wheel is scrolling
      var wheelLastY = null;
      var wheelLastTime = null;

      function handleLeftColumnWheel(wheelEvent) {
        const centerX = getLeftColumnHzCtr();
        const centerY = getLeftColumnVtCtr();
        const mouseX = wheelEvent.clientX;
        const mouseY = wheelEvent.clientY;

        const parallax_dh = centerX - mouseX;
        const parallax_dv = centerY - mouseY;

        applyMotionParallax(parallax_dh, parallax_dv);

        // var thisTime = (new Date()).getTime();
        // var deltaTime = (wheelLastTime != null) ? (thisTime-wheelLastTime) : null;
        // var deltaY = (wheelLastY != null) ? (mouseY - wheelLastY) : null;
        // var wheelVelocity = (deltaTime && deltaY) ? (deltaY)/(deltaTime) : "?";
        // debugScrolling("wheel", leftColumn, "wheelVelocity", wheelVelocity);
        // wheelLastTime =  thisTime;
        // wheelLastY = mouseY;
      }

      // handle mouse enter event for any div element with
      // cardClass "card-div" or "bizcard-div"
      function handleCardDivMouseEnter(event, cardClass) {
        var targetCardDiv = event.target.closest('.' + cardClass);
        if (targetCardDiv) {
          setSelectedStyle(targetCardDiv);
        }
      }

      // handle mouse leave event for any div element with
      // cardClass "card-div" or "bizcard-div"
      function handleCardDivMouseLeave(event, cardClass) {
        var targetCardDiv = event.target.closest('.' + cardClass);
        if (targetCardDiv) {
          restoreSavedStyle(targetCardDiv);
        }
      }

      // works for card-div, bizcard-div, and card-div-line-item
      function setSelectedStyle(div) {
        console.assert(div != null && div.classList != null);
        if (div.classList.contains("card-div-line-item") == false) {
          div.style.zIndex = SELECTED_CARD_DIV_ZINDEX_STR;
          div.style.filter = SELECTED_CARD_DIV_FILTER_STR;
        }
        console.assert(div.hasAttribute("saved-selected-color") &&  div.hasAttribute("saved-selected-background-color"));
        div.style.color = div.getAttribute("saved-selected-color");
        div.style.backgroundColor = div.getAttribute("saved-selected-background-color");
        div.classList.add('selected');
      }

      // works for card-div, bizcard-div, and card-div-line-item
      function restoreSavedStyle(div) {
        console.assert(div != null && div.classList != null);
        if (div.classList.contains("card-div-line-item") == false) {
          console.assert(div.hasAttribute("saved-zIndexStr") && div.hasAttribute("saved-filterStr"));
          div.style.zIndex = div.getAttribute("saved-zIndexStr");
          div.style.filter = div.getAttribute("saved-filterStr");
        }
        console.assert(div.hasAttribute("saved-selected-color") &&  div.hasAttribute("saved-selected-background-color"));
        div.style.color = div.getAttribute("saved-color");
        div.style.backgroundColor = div.getAttribute("saved-background-color");
        div.classList.remove('selected');
      }

      // ------------------------------------------------------------
      // theSelectedCardDiv vars, constants and functions

      const SELECTED_CARD_DIV_Z = ALL_CARDS_MIN_Z;
      const SELECTED_CARD_DIV_ZINDEX_STR = get_zindexStr_from_z(SELECTED_CARD_DIV_Z);
      const SELECTED_CARD_DIV_FILTER_STR = get_filterStr_from_z(SELECTED_CARD_DIV_Z);

      const DEFAULT_TRANSITION_MILLIS = 2000;
      const NO_TRANSITION = 0;
      const NO_TIMEOUT = 0;
      const DEFAULT_SCROLL_INTO_VIEW_OPTIONS = { behavior: 'smooth', block: 'center' };

      function transitionStyleMilis(cardDiv, millis) {
        if (millis > 0) {
          var secs = millis / 1000;
          var cmd = "";
          cmd += `z-index ${secs}s `;
          cmd += `brightness ${secs}s `;
          cmd += `blur ${secs}s `;
          cmd += `color ${secs}s `;
          cmd += `background-color ${secs}s `;
          cardDiv.transition = cmd;
        }
      }

      function selectTheCardDiv(cardDiv) {
        console.assert(cardDiv != null && cardDiv.classList != null);

        // calls deselectTheSelectedCardDiv
        deselectTheSelectedCardDiv();
        // saves self as theSelected
        theSelectedCardDiv = cardDiv;
        // styles self as selected
        setSelectedStyle(theSelectedCardDiv);
        // does not scroll itself into view
      }

      function deselectTheSelectedCardDiv() {
        // if theSelectedCardDiv is defined
        if (theSelectedCardDiv != null) {
          // styles self as saved
          restoreSavedStyle(theSelectedCardDiv);
          // sets the theSelectedCardDiv to null
          theSelectedCardDiv = null;
        }
      }

      // handle mouse click event for any div element with
      // cardClass "card-div" or "bizcard-div".
      function addCardDivClickListener(cardDiv) {
        console.assert(cardDiv != null && isString(cardDiv.id) && cardDiv.classList != null);

        cardDiv.addEventListener("click", function (event) {

          // calls selectTheCardDiv(cardDiv)
          selectTheCardDiv(cardDiv);
          // calls addCardDivLineItem()
          addCardDivLineItem(cardDiv.id);
          var cardDivLineItem = getCardDivLineItem(cardDiv.id);
          console.assert(cardDivLineItem != null );
          // calls selectCardDivLineItem
          selectTheCardDivLineItem(cardDivLineItem);
          // does not scroll self into view
        })
      }

      // ----------------------------------------------
      // cardDiv and cardDivLineItems state transitions
      //
      // cardDiv created
      // see createBizcardDivs
      // see createCardDiv
      //    adds self to document
      //    calls addCardDivClickListener
      //    does not select self
      //    does not scroll self into view

      // selectTheCardDiv(cardDiv)
      //    calls deselectTheSelectedCardDiv()
      //    saves self as theSelected
      //    styles self as selected
      //    does not scroll itself into view

      // deselectTheSelectedCardDiv()
      //    if theSelectedCardDiv is defined
      //      styles self as saved
      //      sets the theSelectedCardDiv to null

      // addCardDivClickListener(cardDiv)
      //    calls selectTheCardDiv(cardDiv)
      //    calls addCardDivLineItem()
      //    calls selectCardDivLineItem
      //    does not scroll self into view

      // addCardDivLineItem(cardDiv)
      //    adds self to document if needed
      //      adds click listener
      //    does not select self
      //    does scroll self into view

      // addTagLinkClickListener(cardDiv)
      //    calls selectTheCardDiv
      //    does scroll cardDiv into view

      // selectTheCardDivLineItem(cardDivLineItem)
      //    calls  deselectTheSelectedCardDivLineItem
      //    saves self as theSelected
      //    styles self as selected
      //    does scroll self into view

      // deselectTheSelectedCardDivLineItem()
      //    if theSelectedCardDivLineItem is defined
      //      styles self as saved
      //      sets the theSelectedCardDivLineItem to null

      // addCardDivLineItemClickListener(cardDivLineItem, cardDiv)
      //    cardDivLineItem selected not clicked
      //    selectTheCardDiv not clicked
      //    does scroll theSelectedCardDiv into view
      // ----------------------------------------------


      function selectTheCardDivLineItem(cardDivLineItem) {
        console.assert(cardDivLineItem != null && cardDivLineItem.classList != null);

        // calls  deselectTheSelectedCardDivLineItem
        deselectTheSelectedCardDivLineItem();
        // saves self as theSelected
        theSelectedCardDivLineItem = cardDivLineItem;
        // styles self as selected
        setSelectedStyle(theSelectedCardDivLineItem);
        // does scroll self into view
        console.log(`scrollIntoView id:${theSelectedCardDivLineItem.id}`);
        theSelectedCardDivLineItem.scrollIntoView(DEFAULT_SCROLL_INTO_VIEW_OPTIONS);
      }

      function deselectTheSelectedCardDivLineItem() {
        // if theSelectedCardDivLineItem is defined
        if (theSelectedCardDivLineItem != null) {
          // styles self as saved
          restoreSavedStyle(theSelectedCardDivLineItem);
          // sets the theSelectedCardDivLineItem to null
          theSelectedCardDivLineItem = null;
        }
      }

      function addCardDivLineItemClickListener(cardDivLineItem, cardDiv) {
        console.assert(cardDivLineItem != null && cardDiv != null);

        cardDivLineItem.addEventListener("click", function (event) {
          // cardDivLineItem selected not clicked
          selectTheCardDivLineItem(cardDivLineItem);
          // selectTheCardDiv not clicked
          selectTheCardDiv(cardDiv);
          // does scroll theSelectedCardDiv into view
          console.log(`scrollIntoView id:${cardDiv.id}`);
          cardDiv.scrollIntoView(DEFAULT_SCROLL_INTO_VIEW_OPTIONS);
        })
      }

      // add a new card-div-line-item to right-column-content
      // if one doesn't aleady exist
      function addCardDivLineItem(targetCardDivId) {

        if (targetCardDivId == null) {
          console.log(`ignoring request to add cardDivLineItem with null targetCardDivId`);
          return;
        }

        // check to see if the cardDiv exists
        var targetCardDiv = document.getElementById(targetCardDivId);
        if (targetCardDiv == null) {
          console.log(`no cardDiv found for targetCardDivId:${targetCardDivId}`);
          return;
        }

        // only add a card-div-line-item for this targetCardDivId if
        // it hasn't already been added
        var existingCardDivLineItem = getCardDivLineItem(targetCardDivId);
        if (existingCardDivLineItem == null) {

          var cardDivLineItem = document.createElement("li");
          cardDivLineItem.classList.add("card-div-line-item");
          cardDivLineItem.id = "card-div-line-item-" + targetCardDivId;
          cardDivLineItem.setAttribute("targetCardDivId", targetCardDivId);

          // add click listener
          addCardDivLineItemClickListener(cardDivLineItem, targetCardDiv);

          // inherit colors of targetCardDiv
          copyAttributes(cardDivLineItem, targetCardDiv, [
            "saved-background-color",
            "saved-color",
            "saved-selected-background-color",
            "saved-selected-color"
          ])

          cardDivLineItem.style.backgroundColor = cardDivLineItem.getAttribute("saved-background-color") || "";
          cardDivLineItem.style.color = cardDivLineItem.getAttribute("saved-color") || "";

          // set content
          var cardDivLineItemContent = document.createElement("div");
          cardDivLineItemContent.classList.add("card-div-line-item-content");
          cardDivLineItemContent.style.backgroundColor = targetCardDiv.getAttribute("saved-background-color") || "";
          cardDivLineItemContent.style.color = targetCardDiv.getAttribute("saved-color") || "";

          var cardDivLineItemRightColumn = document.createElement('div')
          cardDivLineItemRightColumn.classList.add("card-div-line-item-right-column");

          // start with the innerHTML of the targetCardDiv
          var targetInnerHTML = targetCardDiv.innerHTML;
          if (targetInnerHTML && targetInnerHTML.length > 0) {

            // ensure targetInnerHTML includes no img tag markup
            if (targetInnerHTML.includes("<img"))
              targetInnerHTML = removeImgTagsFromHtml(targetInnerHTML);

            cardDivLineItemContent.innerHTML = targetInnerHTML;
          }

          // if targetCardDiv has a "Description" attribute
          var description = targetCardDiv.getAttribute("Description");
          if (description && description.length > 0) {
            // split the description by BULLET_SEPARATORS and return html 
            // of the styled form <p><ul>(<li>text</li>)+</ul></p>
            // where text contains spans that have targetCardDivIds
            var line_items_HTML = convert_description_HTML_to_line_items_HTML(description);
            if (line_items_HTML && line_items_HTML.length > 0) {

              // ensure line_items_HTML includes no img tag markup
              if (line_items_HTML.includes("<img"))
                line_items_HTML = removeImgTagsFromHtml(line_items_HTML);

              cardDivLineItemContent.innerHTML += line_items_HTML
            }
          }

          // add cardDivLineItem's delete button, which deletes the cardDivLineItem
          var cardDivLineItemDeleteButton = document.createElement("button");
          cardDivLineItemDeleteButton.classList.add("card-div-line-item-delete-button");
          cardDivLineItemDeleteButton.addEventListener("click", function (event) {
            cardDivLineItem.remove();
            event.stopPropagation();
          });
          cardDivLineItemRightColumn.appendChild(cardDivLineItemDeleteButton);

          // add cardDivLineItem "following" button if the targetCardDiv is a bizcardDiv
          if (isBizcardDiv(targetCardDiv)) {
            var followingBizcardDivId = getFollowingBizcardDivId(targetCardDivId);
            if (followingBizcardDivId) {
              var cardDivLineItemFollowingButton = document.createElement("button");
              cardDivLineItemFollowingButton.classList.add("card-div-line-item-follow-button");
              cardDivLineItemFollowingButton.addEventListener("click", function (event) {
                // add a new cardDivLineItem if possible
                addCardDivLineItem(followingBizcardDivId);
                event.stopPropagation();
              });
              cardDivLineItemRightColumn.appendChild(cardDivLineItemFollowingButton);
            }
          }

          cardDivLineItem.appendChild(cardDivLineItemContent);
          cardDivLineItem.appendChild(cardDivLineItemRightColumn);
          rightContentDiv.appendChild(cardDivLineItem);

          // find all .tagLinks of this cardDivLineItem
          // and give them onclick listeners
          var tagLinks = cardDivLineItem.querySelectorAll('.tagLink');
          for (let i = 0; i < tagLinks.length; i++) {
            addTagLinkClickListener(tagLinks[i]);
          }
        } else {
          console.log(`ignoring request to add duplicate cardDiv with targetCardDivId:${targetCardDivId}`);
        }
        // does not select self
        // does scroll self into view
      }


      // --------------------------------------------------------------

      // return the cardDivLineItem in rightCOntentDiv for cardDivId or null if not found
      function getCardDivLineItem(cardDivId) {
        console.assert( isString(cardDivId) );
        for (var i = 0; i < rightContentDiv.children.length; i++) {
          var child = rightContentDiv.children[i];
          if (child.className == "card-div-line-item") {
            if (child.hasAttribute("targetCardDivId") &&
              child.getAttribute("targetCardDivId") == cardDivId) {
              return child;
            }
          }
        }
        return null;
      }

      // return the next bizcardDivId if one exists and has not
      // already been added to rightColumnContentDiv, else null
      function getFollowingBizcardDivId(bizcardDivId) {
        if (!isString(bizcardDivId) && bizcardDivId != null);
        var index = getBizcardDivIndex(bizcardDivId);
        if (index != null) {
          var followingBizcardDivId = getBizcardDivIdFromIndex(index + 1);
          // if we've reached the end of all bizcardDivs
          // then start over at index 0
          if (followingBizcardDivId == null)
            followingBizcardDivId = getBizcardDivIdFromIndex(0);

          if (followingBizcardDivId) {
            // has a cardDivLineItem not already been added for followingBizcardDivId?
            var cardDivLineItem = getCardDivLineItem(bizcardDivId);
            if (cardDivLineItem == null) {
              return followingBizcardDivId;
            }
          }
        }
        // this should never be reached
        return null;
      }

      // remove multiple img tags from the given html string
      function removeImgTagsFromHtml(html) {
        var filtered = html.replace(/<img[^>"']*((("[^"]*")|('[^']*'))[^"'>]*)*>/g, "");
        console.assert( !filtered.includes("<img") );
        return filtered;
      }

      function addTagLinkClickListener(tagLink) {
        console.assert(tagLink != null);
        tagLink.addEventListener("click", function(event) {
          var tagLinkId = event.target.id;
          // get the cardDivId from the tagLinkId
          var cardDivId = tagLinkId.replace("tagLink-", "");
          // find the cardDivId is of the form "card-div-<int>""
          var cardDiv = document.getElementById(cardDivId);
          if (cardDiv) {
            var tagLinkText = cardDiv.getAttribute("tagLinkText");
            var tagLinkUrl = cardDiv.getAttribute("tagLinkUrl");
            console.assert(tagLinkText != null && tagLinkUrl != null);
            
            // calls selectTheCardDiv
            console.log(`tagLink with text:[${tagLinkText}] url:(${tagLinkUrl}) selected cardDiv:%{cardDiv.id}`);
            selectTheCardDiv(cardDiv);
            // does scroll cardDiv into view
            console.log(`scrollIntoView id:${cardDiv.id}`);
            cardDiv.scrollIntoView(DEFAULT_SCROLL_INTO_VIEW_OPTIONS);
          } else {
            console.log(`no cardDiv with tagLink found for cardDivId:${cardDivId}`);
          }
          event.stopPropagation();

        });
      }


      function renderAllTranslateableDivsAtLeftColumnCenter() {
        const leftColumnCenter = getLeftColumnHzCtr();
        const translateableDivs = getAllTranslateableCardDivs();
        for (const div of translateableDivs) {
          const divWidth = div.offsetWidth;
          const trans_dx = leftColumnCenter - divWidth / 2.0;
          const trans_dy = 0;
          const translateStr = `${trans_dx}px ${trans_dy}px`;
          try {
            div.style.translate = translateStr;
          } catch (error) {
            console.log(`leftCenter div:${div.id}`, error);
            console.error(`leftCenter div:${div.id}`, error);
          }
        }
        // console.log(`leftColumn.scrollHeight:${leftColumn.scrollHeight}`);
      }

      function positionGradients() {
        const canvasHeight = canvas.scrollHeight;
        const bottomGradientHeight = bottomGradient.offsetHeight;
        bottomGradient.style.top = `${canvasHeight - bottomGradientHeight}px`;
      }

      function rightContentScrollToBottom() {
        rightContentDiv.scrollTop = rightContentDiv.scrollHeight;
      }

      function leftColumnScrollToYear(year) {
        var totalYears = TIMELINE_MAX_YEAR - TIMELINE_MIN_YEAR + 1;
        var leftColumScrollPixelsPerYear = leftColumn.scrollHeight / totalYears;

        var newScrollTop = (TIMELINE_MAX_YEAR - year) * leftColumScrollPixelsPerYear;
        newScrollTop = clamp(newScrollTop, 0, leftColumn.scrollHeight);
        // console.log(`newScrollTop:${newScrollTop}`);

        leftColumn.scrollTop = newScrollTop;
      }

      function centerBullsEye() {
        var top = getLeftColumnVtCtr() - getElementSelfVtCtr(bulls_eye);
        var left = getLeftColumnHzCtr() - getElementSelfHzCtr(bulls_eye);
        bulls_eye.style.top = `${top}px`;
        bulls_eye.style.left = `${left}px`;
        // console.log(`bulls-eye top:${top} left:${left}`);
      }

      function updateSkillsFromAllTagLinks(allTagLinks) {
        if (allTagLinks && allTagLinks.length > 0) {
          const html = allTagLinks.map((list) => list.text).join(BULLET_JOINER);
          const skills = document.getElementById("skills");
          skills.innerHTML = html;
        } else {
          console.log("no skills yet");
        }
      }

      function handleWindowLoad() {
        createTimeline();
        createBizcardDivs();
        renderAllTranslateableDivsAtLeftColumnCenter();
        positionGradients();
        leftColumnScrollToYear(TIMELINE_DEFAULT_YEAR);
        centerBullsEye();
      }

      function handleWindowResize() {
        // resize the left-column and the canvas since they don't do it themselves?
        var windowWidth = window.innerWidth;
        var leftColumnWidth = windowWidth / 2;

        document.getElementById("left-column").style.width =
          leftColumnWidth + "px";
        document.getElementById("canvas").style.width = leftColumnWidth + "px";
        renderAllTranslateableDivsAtLeftColumnCenter();
        positionGradients();
        centerBullsEye();
      }

      // Attach event listeners
      window.addEventListener("load", handleWindowLoad);
      window.addEventListener("resize", handleWindowResize);
      leftColumn.addEventListener("mousemove", handleLeftColumnMouseMove);
      leftColumn.addEventListener("load", handleLeftColumnMouseMove);
      leftColumn.addEventListener("wheel", handleLeftColumnWheel, {
        passive: true,
      });
      leftColumn.addEventListener('mouseenter', handleMouseEnterLeftColumn);
      leftColumn.addEventListener('mouseleave', handleMouseLeaveLeftColumn);
      leftColumn.addEventListener('scroll', handleLeftColumnScroll);


    </script>
</body>

</html>