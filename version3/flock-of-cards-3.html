<!DOCTYPE html>
<html>
  <head>
    <title>flock-of-cards-3</title>
    <link rel="stylesheet" type="text/css" href="flock-of-cards-3.css">
  </head>
  <body>
    <div id="container">
      <div id="left-column">
        <div id="canvas">
        <div id="top-gradient"></div>
        <div id="bottom-gradient"></div>
        <div id="timeline-container"></div>
      </div>
    </div>
    <div id="right-column">
      <div id="right-column-content"> 
      </div> 
    </div>

    <script>
      // this is set in the createBizDivCards
      var num_biz_cards = 0;

      // this is a constant of now
      const NUM_CARDS = 50;

      const rightColumnContent = document.getElementById("right-column-content");
      const leftColumn = document.getElementById("left-column");
      const canvas = document.getElementById("canvas");
      const bottomGradient = document.getElementById("bottom-gradient");
      const timelineContainer = document.getElementById(
        "timeline-container"
      );

      // ground is zindex = 0 and zindex is offset from ground,
      // and z is distance to viewer, so z = MAX_Z - zindex,
      // conversely zindex = MAX_Z - z.
      const ALL_CARDS_MAX_Z = 15;
      const BIZCARD_MAX_Z = 14;
      const BIZCARD_MIN_Z = 12;
      const CARD_MAX_Z = 8;
      const CARD_MIN_Z = 1;
      const ALL_CARDS_MIN_Z = 1;

      // bizcard width decreases as zindex increases
      const BIZCARD_WIDTH_IN = 2.0;
      const BIZCARD_INDENT_IN = 0.2;
      const BIZCARD_OVERLAP_BOTTOM_IN = 0.0;

      // card brightness decreases to MIN_BRIGHTNESS_PERCENT as z increases
      const MIN_BRIGHTNESS_PERCENT = 75;

      // card blur increases as z increases
      const BLUR_Z_SCALE_FACTOR = 4;

      // card metrix in pixels
      const MAX_CARD_OFFSET = 200;
      const CARD_MARGIN_VT = 5;
      const MEAN_CARD_HEIGHT = 75;
      const MEAN_CARD_WIDTH = 100;
      const CARD_DIV_DIALOG_OFFSET = 20;
      const CARD_DIV_DIALOG_ZINDEX = 30;

      const PARALLAX_HZ_EXAGGERATION_FACTOR = 0.05;
      const PARALLAX_VT_EXAGGERATION_FACTOR = 0.1;

      // YEAR metrics in inches
      const YEAR_DIV_MAX_YEAR = 2023;
      const YEAR_DIV_MIN_YEAR = 1977;
      const YEAR_TOP_TO_TOP = 27 / 16;
      const YEARDIV_FONTSIZE = 0.5;
      const MONTHTICK_FONTSIZE = 0.07;

      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const adjustRgbBrightness = (rgb, brightness) => rgb.map(channel => clamp(Math.round(channel * brightness),0,255));
      const adjustHexBrightness = (hex, brightness) => getHexFromRGB(adjustRgbBrightness(getRGBfromHex(hex), brightness));
      const getHexFromRGB = color => "#" + color.map(c => c.toString(16).padStart(2, "0")).join("").toLowerCase();
      const getRGBfromHex = hex => hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i)?.slice(1).map(c => parseInt(c, 16));
      const toFixedPoint = (value, precision) => +value.toFixed(precision);
      const linearInterp = (x, x1, y1, x2, y2) => y1 + ((x - x1) / (x2 - x1)) * (y2 - y1);
      const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const zeroPad = (num, places) => num.toString().padStart(places, "0");
      const getHSVfromRGB = ([r, g, b]) => {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const delta = max - min;
        const s = max !== 0 ? delta / max : 0;
        let h = max === min ? 0 : (max === r ? (g - b) / delta + (g < b ? 6 : 0) : max === g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
        if (isNaN(h)) h = 0;
        return [h, s, max];
      };
      const getRGBfromHSV = ([h, s, v]) => {
        const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)].map(Math.round);
      };

      function get_zindexStr_from_z(z) {
        return `${ALL_CARDS_MAX_Z - z}`;
      }

      function get_z_from_zindexStr(zindex) {
        return ALL_CARDS_MAX_Z - parseInt(zindex);
      }

      // returns a filter brightness string between 100% and 75%
      // brightness dims as z increases
      function get_brightness_str_from_z(z) {
        var bright = linearInterp(
          z,
          CARD_MIN_Z,
          1.0,
          CARD_MAX_Z,
          MIN_BRIGHTNESS_PERCENT / 100.0
        );
        bright = Math.round(bright * 100) / 100;
        var perc = `${100 * bright}%`;
        return `brightness(${perc})`;
      }

      // returns a filter blur string
      // blur increases as z increases
      function get_blur_str_from_z(z) {
        var blur = (z - CARD_MIN_Z) / BLUR_Z_SCALE_FACTOR;
        return `blur(${blur}px)`;
      }

      // returns a z-relative parallax scale factor
      // parallax increases as z decreases
      function getZscale(z) {
        return parseInt(get_zindexStr_from_z(z));
      }

      var timelineYearDivTops = {};

      function initTimelineYearDivTops() {
        timelineYearDivTops = {}
      }

      // used to get canvas-relative top position for anything 
      // take care to always append "in" for inches
      function getTimelineYearMonthTopIn(yearStr,monthStr) {
        var month = parseInt(monthStr,10);
        return timelineYearDivTops[yearStr] - (month-1)*YEAR_TOP_TO_TOP/12;
      }

      // append year-divs and year-dashes into timeline-container
      function createTimeline() {
        initTimelineYearDivTops();
        var yearDash = (yearDivTop = yearDiv = null);

        for (var year = YEAR_DIV_MAX_YEAR; year >= YEAR_DIV_MIN_YEAR; year--) {
          yearDiv = document.createElement("div");
          yearDiv.className = "year-div";
          var row = YEAR_DIV_MAX_YEAR - year;
          yearDivTop = (row+1) * YEAR_TOP_TO_TOP;
          timelineYearDivTops[`${year}`] = yearDivTop;

          yearDiv.style.fontSize = `${YEARDIV_FONTSIZE}in`;
          yearDiv.style.top = `${yearDivTop - YEARDIV_FONTSIZE}in`;
          yearDiv.innerHTML = `${year}&nbsp;`;
          timelineContainer.appendChild(yearDiv);

          for ( var month=12; month>=1; month-- ) {
            monthTick = document.createElement("div");
            monthTick.className = "month-tick";
            var monthStr = zeroPad(month, 2);
            var monthTickTop = getTimelineYearMonthTopIn(year,monthStr);
            var check = yearDivTop - (month-1) * YEAR_TOP_TO_TOP/12;
            if ( monthTickTop != check )
              console.log(`WARNING: ${monthTickTop} != check:${check}`);
            monthTick.style.fontSize = `${MONTHTICK_FONTSIZE}in`;
            monthTick.style.top = `${monthTickTop - MONTHTICK_FONTSIZE}in`;
            monthTick.innerHTML = `${year}-${monthStr}`;
            timelineContainer.appendChild(monthTick);
          }
        }
      }

      function createBizCardDivs() {

        const jobs = [{"role":"Consulting Data Engineer","employer":"The Cigna Group","start":"2023-05-01","end":"2023-07-01","years":"0.17","z-index":"1","excel crayon":"ocean","exel swatch":"","css name":"darkcyan","css HEX color":"#008b8b","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Data Engineer","employer":"Warner Brothers Interactive Entertainment","start":"2022-09-01","end":"2023-05-01","years":"0.66","z-index":"2","excel crayon":"blueberry","exel swatch":"","css name":"blue","css HEX color":"#0000ff","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Data Engineer","employer":"Angel Studios","start":"2021-11-01","end":"2022-09-01","years":"0.83","z-index":"1","excel crayon":"midnight","exel swatch":"","css name":"indigo","css HEX color":"#4B0082","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Data Engineer","employer":"Greenseed Tech","start":"2020-01-01","end":"2021-11-01","years":"1.84","z-index":"2","excel crayon":"eggplant","exel swatch":"","css name":"blueviolet","css HEX color":"#8a2be2","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Full-Stack Developer","employer":"NuSkin","start":"2019-11-01","end":"2020-11-01","years":"1.00","z-index":"1","excel crayon":"plum","exel swatch":"","css name":"purple","css HEX color":"#800080","css HEX swatch":"","text color":"white","last column":""},{"role":"Senior Data Engineer","employer":"SeniorLiink","start":"2017-03-01","end":"2019-11-01","years":"2.67","z-index":"2","excel crayon":"maroon","exel swatch":"","css name":"maroon","css HEX color":"#800000","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Back-End Engineer","employer":"BigR.io","start":"2016-12-01","end":"2017-03-01","years":"0.25","z-index":"1","excel crayon":"marichino","exel swatch":"","css name":"crimson","css HEX color":"#dc143c","css HEX swatch":"","text color":"white","last column":""},{"role":"Software Architect / Co-Founder","employer":"ClipFile LLC","start":"2011-02-01","end":"2016-12-01","years":"5.84","z-index":"2","excel crayon":"tangerine","exel swatch":"","css name":"orangered","css HEX color":"#ff4500","css HEX swatch":"","text color":"white","last column":""},{"role":"Software Architect / Co-Founder","employer":"Sierra Vista Group LLC","start":"2002-11-01","end":"2011-02-01","years":"8.26","z-index":"1","excel crayon":"cantalope","exel swatch":"","css name":"orange","css HEX color":"#ffa500","css HEX swatch":"","text color":"black","last column":""},{"role":"Software Architect / Co-Founder","employer":"HomePorfolio LLC","start":"1998-02-01","end":"2002-11-01","years":"4.75","z-index":"1","excel crayon":"teal","exel swatch":"","css name":"yellow","css HEX color":"#ffff00","css HEX swatch":"","text color":"black","last column":""},{"role":"Lead Software Developer","employer":"BuildingBlocks LLC","start":"1996-06-01","end":"1998-02-01","years":"1.67","z-index":"1","excel crayon":"ocean","exel swatch":"","css name":"lime","css HEX color":"#00ff00","css HEX swatch":"","text color":"black","last column":""},{"role":"Ph.D. Media Arts & Science","employer":"MIT Media Lab","start":"1990-09-01","end":"1997-04-01","years":"6.59","z-index":"2","excel crayon":"blueberry","exel swatch":"","css name":"limegreen","css HEX color":"#32cd32","css HEX swatch":"","text color":"black","last column":""},{"role":"MS Computer Science","employer":"BYU","start":"1987-09-01","end":"1990-09-01","years":"3.00","z-index":"2","excel crayon":"midnight","exel swatch":"","css name":"olivedrab","css HEX color":"#6b8e23","css HEX swatch":"","text color":"white","last column":""},{"role":"Software Developer","employer":"Cimmetrix LLC","start":"1989-06-01","end":"1990-09-01","years":"1.25","z-index":"1","excel crayon":"eggplant","exel swatch":"","css name":"forestgreen","css HEX color":"#228b22","css HEX swatch":"","text color":"white","last column":""},{"role":"BS Design Engineering Technology","employer":"BYU","start":"1983-09-01","end":"1987-09-01","years":"4.00","z-index":"2","excel crayon":"plum","exel swatch":"","css name":"teal","css HEX color":"#008080","css HEX swatch":"","text color":"white","last column":""},{"role":"Call Center Reservationist","employer":"Dell Webb Properties","start":"1984-01-01","end":"1984-09-01","years":"0.67","z-index":"1","excel crayon":"maroon","exel swatch":"","css name":"darkcyan","css HEX color":"#008b8b","css HEX swatch":"","text color":"white","last column":""},{"role":"Missonary","employer":"Taiwan Taibei Mission","start":"1982-08-01","end":"1984-01-01","years":"1.42","z-index":"3","excel crayon":"marichino","exel swatch":"","css name":"blue","css HEX color":"#0000ff","css HEX swatch":"","text color":"white","last column":""},{"role":"BS GED","employer":"BYU","start":"1981-09-01","end":"1982-08-01","years":"0.92","z-index":"2","excel crayon":"tangerine","exel swatch":"","css name":"indigo","css HEX color":"#4B0082","css HEX swatch":"","text color":"white","last column":""},{"role":"Data Processing","employer":"Greyhound Corp","start":"1981-04-01","end":"1981-09-01","years":"0.42","z-index":"1","excel crayon":"cantalope","exel swatch":"","css name":"blueviolet","css HEX color":"#8a2be2","css HEX swatch":"","text color":"white","last column":""},{"role":"Newspaper Delivery","employer":"Arizona Republic","start":"1977-09-01","end":"1981-04-01","years":"3.58","z-index":"1","excel crayon":"lemon","exel swatch":"","css name":"purple","css HEX color":"#800080","css HEX swatch":"","text color":"white","last column":""},{"role":"Project Manager / Technical Lead","employer":"MSC","start":"2007-12-01","end":"2011-02-01","years":"3.17","z-index":"2","excel crayon":"lemon","exel swatch":"","css name":"maroon","css HEX color":"#800000","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Architect","employer":"Eleven LLC","start":"2006-02-01","end":"2007-12-01","years":"1.83","z-index":"2","excel crayon":"lime","exel swatch":"","css name":"crimson","css HEX color":"#dc143c","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Architect","employer":"Intrusic LLC","start":"2005-02-01","end":"2006-02-01","years":"1.00","z-index":"2","excel crayon":"spring","exel swatch":"","css name":"orangered","css HEX color":"#ff4500","css HEX swatch":"","text color":"white","last column":""},{"role":"Consulting Architect / Technical Lead","employer":"AMI Entertainment","start":"2004-02-01","end":"2005-02-01","years":"1.00","z-index":"2","excel crayon":"moss","exel swatch":"","css name":"orange","css HEX color":"#ffa500","css HEX swatch":"","text color":"black","last column":""},{"role":"Consulting Architect / Technical Lead","employer":"Rowe International","start":"2003-03-01","end":"2004-02-01","years":"0.92","z-index":"2","excel crayon":"clover","exel swatch":"","css name":"yellow","css HEX color":"#ffff00","css HEX swatch":"","text color":"black","last column":""}];

        var num_valid_rows = 0;
        for (let i=0; i<jobs.length; i++) {
          job = jobs[i];
          var role = job["role"];
          var employer = job["employer"].trim();
          var css_hex_color = job["css HEX color"].trim();
          var font_color_name = job["text color"].trim();

          // timeline is descending so jobEnd is always above jobStart
          var jobEnd = job["end"].trim().replace("-01","");
          var endYearStr = jobEnd.split("-")[0];
          var endMonthStr = jobEnd.split("-")[1];
          var topInches = getTimelineYearMonthTopIn(endYearStr,endMonthStr);

          var jobStart = job["start"].trim().replace("-01","");
          var startYearStr = jobStart.split("-")[0];
          var startMonthStr = jobStart.split("-")[1];
          var bottomInches = getTimelineYearMonthTopIn(startYearStr,startMonthStr);

          var heightInches = bottomInches - topInches;
          console.assert(bottomInches > topInches);
          console.assert(heightInches > 0);
          var zIndex = parseInt(job["z-index"].trim());

          // continue to next row if zIndex is undefined
          if (typeof zIndex == "undefined") {
            console.log(`zIndex undefined at i:${i}`);
            continue
          } 
          var indent =  (zIndex - 1) * BIZCARD_INDENT_IN;

          bizcardDiv = document.createElement("div");
          if (num_biz_cards != 0) {
            throw new Error("Value of num_biz_cards is not zero!");
          }
          bizcardDiv.id = num_biz_cards + i;
          bizcardDiv.className = "bizcard-div";
          bizcardDiv.style.top = `${topInches}in`;
          bizcardDiv.style.height = `${heightInches}in`;
          bizcardDiv.style.left = `${indent}in`;
          bizcardDiv.style.width = `${BIZCARD_WIDTH_IN}in`;
          bizcardDiv.style.zIndex = `${zIndex}`;

          bizcardDiv.setAttribute("saved-background-color", css_hex_color);
          bizcardDiv.setAttribute("saved-color", font_color_name);
          bizcardDiv.setAttribute("saved-focus-background-color", adjustHexBrightness(css_hex_color,1.3));
          bizcardDiv.setAttribute("saved-focus-color", "black");

          bizcardDiv.style.backgroundColor = bizcardDiv.getAttribute("saved-background-color");
          bizcardDiv.style.color = bizcardDiv.getAttribute("saved-color");

          var html = "";
          html += `${role}<br/>`;
          html += `${employer}<br/>`;
          html += `${jobStart} - ${jobEnd}<br/>`;
          bizcardDiv.innerHTML = html;

          bizcardDiv.addEventListener("mouseenter", handleBizCardDivMouseEnter);
          bizcardDiv.addEventListener("mouseleave", handleBizCardDivMouseLeave);
          bizcardDiv.addEventListener("click", handleBizCardDivMouseClick);

          canvas.appendChild(bizcardDiv);
          num_valid_rows++;
        }
        num_biz_cards = num_valid_rows;
        renderAllCenterableDivsAtLeftColumnCenter();
      }

      // adds a vertical stack of cardDivs to #canvas
      // each with random x,y offsets and random
      // z levels, and z-varied brightness and blur.
      function createCardDivs() {
        var prevZIndex = null; // Track the previous z-index value
        var min_id_inclusive = num_biz_cards;
        var max_id_exclusive = num_biz_cards + NUM_CARDS;
        for (let id = min_id_inclusive; id < max_id_exclusive; id++) {
          const cardDiv = document.createElement("div");
          cardDiv.id = id;
          cardDiv.className = "card-div";
          cardDiv.style.height = MEAN_CARD_HEIGHT + "px";
          const verticalOffset = getRandomInt(-MAX_CARD_OFFSET,MAX_CARD_OFFSET);
          var verticalDistance = MEAN_CARD_HEIGHT + CARD_MARGIN_VT;
          var top = MEAN_CARD_HEIGHT / 2 + (id - min_id_inclusive) * verticalDistance + verticalOffset
          cardDiv.style.top = `${top}px`;
          cardDiv.style.width = MEAN_CARD_WIDTH + "px";
          var left = getRandomInt(-MAX_CARD_OFFSET,MAX_CARD_OFFSET);
          cardDiv.style.left = `${left}px`;

          var z = getRandomInt(CARD_MIN_Z, CARD_MAX_Z);
          while (z === prevZIndex) {
            // Generate a new z if it's the same as the previous one
            z = getRandomInt(CARD_MIN_Z, CARD_MAX_Z);
          }
          var zindexStr = get_zindexStr_from_z(z);
          cardDiv.style.zIndex = zindexStr;
          var filter_brightness_str = get_brightness_str_from_z(z);
          var filter_blur_str = get_blur_str_from_z(z);
          filter_strs = `${filter_brightness_str} ${filter_blur_str}`;
          cardDiv.style.filter = filter_strs;
          cardDiv.innerHTML = `id:${id}<br/>z:${z}<br/>zindexStr:${zindexStr}<br/>${filter_blur_str}`;
          canvas.appendChild(cardDiv);

          var css_hex_color = "#CC0000";
          cardDiv.setAttribute("saved-background-color", css_hex_color);
          cardDiv.setAttribute("saved-color", "black");
          cardDiv.setAttribute("saved-focus-background-color", adjustHexBrightness(css_hex_color, 1.3));
          cardDiv.setAttribute("saved-focus-color", "black");

          cardDiv.style.backgroundColor = cardDiv.getAttribute("saved-background-color");
          cardDiv.style.color = cardDiv.getAttribute("saved-color");

          cardDiv.addEventListener("mouseenter", handleCardDivMouseEnter);
          cardDiv.addEventListener("mouseleave", handleCardDivMouseLeave);
          cardDiv.addEventListener("click", handleCardDivMouseClick);

          prev_z = z;

          if (z == CARD_MAX_Z) {
            cardDiv.style.backgroundColor = "maroon";
            console.log(`cardDiv[${id}] initialized to maroon`);
          }
        }
        renderAllCenterableDivsAtLeftColumnCenter();
      }

      /**
       * Summary. Returns the translate string used to transform
       * any cardDiv's x,y coordinates into canvas-relative coordinates.
       * this assortment of divs has only a fixed number of possible
       * z values so the results of this function are cashed for
       * speed of access.
       *
       * Description. (use period)
       * @param {float}  dh           the horizontal parallax offset value
       * @param {float}  dv           the vertical parallax offet value
       * @param {int}    z            the random Z depth assigned to every cardDiv
       *                              where z ranges from 1 as max dist to viewer
       *                              to ALL_CARDS_MAX_Z being closest to viewer
       *                              with an integer value between CARD_MIN_Z and CARD_MAX_Z
       * @param {float}  canvas_dx    the x value used to convert cardDiv.x to canvas-relative position
       * @param {float}  canvas_dy    the y value used to convert cardDiv.y canvas-relative position
       *
       * @return {str} Return a string with format "12.02px -156.79px"
       */
      function getZTranslateStr(dh, dv, z, canvas_dx, canvas_dy) {
        // zScale increases to max translation as z approaches MAX_Z
        // zScale decreases to 1 as as z approaches 1
        zScale = getZscale(z);

        // by definition, divs have zero mean hzCtrs so canvas translation is required
        dx = toFixedPoint(dh * zScale + canvas_dx, 2);
        dy = toFixedPoint(dv * zScale + canvas_dy, 2);
        zTranslateStr = `${dx}px ${dy}px`;

        return zTranslateStr;
      }

      // return the horizontal center of the left-column
      function getLeftColumnHzCtr() {
        return leftColumn.offsetWidth / 2;
      }
      // return the vertical center of the left-column
      function getLeftColumnVtCtr() {
        return leftColumn.offsetHeight / 2;
      }
      // return the horizontal center of the canvas
      function getCanvasHzCtr() {
        return canvas.offsetWidth / 2;
      }
      // return the vertical center of the canvas
      function getCanvasVtCtr() {
        return canvas.offsetHeight / 2;
      }
      // return the horizontal center of the given cardDiv
      function getCardDivHzCenter(cardDiv) {
        return cardDiv.offsetWidth / 2;
      }
      // return the vertical center of the given cardDiv
      function getCardDivVtCenter(cardDiv) {
        return cardDiv.offsetHeight / 2;
      }


      function getAllCenterableDivs() {
        allCenterableDivs = [];
        allCenterableDivs = Array.prototype.concat.apply(
          allCenterableDivs,
          canvas.getElementsByClassName("bizcard-div")
        );
        allCenterableDivs = Array.prototype.concat.apply(
          allCenterableDivs,
          canvas.getElementsByClassName("card-div")
        );
        allCenterableDivs = Array.prototype.concat.apply(
          allCenterableDivs,
          canvas.getElementsByClassName("card-div-dialog")
        );
        return allCenterableDivs;
      }

      // lazy-loaded
      var allTranslateableDivs = null;

      // return all bizcardDivs and cardDivs lazy-loaded
      function getAllTranslateableDivs(force) {
        if (force) allTranslateableDivs = null;
        if (allTranslateableDivs == null) {
          allTranslateableDivs = [];
          // allTranslateableDivs = Array.prototype.concat.apply(
          //   allTranslateableDivs,
          //   canvas.getElementsByClassName("bizcard-div")
          // );
          allTranslateableDivs = Array.prototype.concat.apply(
            allTranslateableDivs,
            canvas.getElementsByClassName("card-div")
          );
          // allTranslateableDivs = Array.prototype.concat.apply(
          //   allTranslateableDivs,
          //   canvas.getElementsByClassName("card-div-dialog")
          // );
        }
        return allTranslateableDivs;
      }

      // applies z-depth scaled parallax to all cardDivs
      function applyMotionParallax(parallax_dh, parallax_dv) {
        // constant for the current view
        var canvasHzCtr = getCanvasHzCtr();
        var canvasVtCtr = getCanvasVtCtr();

        // constants for this parallax
        var dh = parallax_dh * PARALLAX_HZ_EXAGGERATION_FACTOR;
        var dv = parallax_dv * PARALLAX_VT_EXAGGERATION_FACTOR;

        // compute translations for all translatableDivs
        var allDivs = getAllTranslateableDivs((force = true));
        for (var i = 0; i < allDivs.length; i++) {
          var cardDiv = allDivs[i];
          var zIndexStr = cardDiv.style.zIndex;
          var z = get_z_from_zindexStr(zIndexStr);

          // canvas-relative cardDiv center
          var canvas_dx = canvasHzCtr - getCardDivHzCenter(cardDiv);
          var canvas_dy = canvasVtCtr - getCardDivVtCenter(cardDiv);

          var zTranslateStr = getZTranslateStr(dh, dv, z, canvas_dx, canvas_dy);

          cardDiv.style.translate = zTranslateStr;
        }
      }

      var scrollingInterval = null;

      // Function to handle transform cardDivs according
      // to current left-column position. Given null
      // when called from onload, in this case
      // left-column center as mouse location
      function handleLeftColumnMouseMove(event) {
        var rect = leftColumn.getBoundingClientRect();
        var centerX = rect.left + rect.width / 2;
        var centerY = rect.top + rect.height / 2;

        var mouseX = centerX;
        var mouseY = centerY;
        if (event) {
          mouseX = event.clientX;
          mouseY = event.clientY;
        }

        var dist_v = mouseY - centerY;
        var delta_vt = ((mouseY - centerY) / centerY) * 100;
        var parallax_dh = (parallax_dv = scroll_vt = 0);

        // normal mouse-driven parallax
        if (Math.abs(delta_vt) < 50) {
          parallax_dh = centerX - mouseX;
          parallax_dv = centerY - mouseY;
        } else {
          // maximum vertical aiut-scroll velocity
          const MAX_SCROLL_VT = 10.0;

          // start to scroll when mouse is > 50% of distance
          // from center  to top or bottom edge of viewport
          // scroll_vt velocty is zero at 50% of distance from
          // center. scroll_vt velocity speeds up linearly
          // to MAX_SCROLL_VT when mouseX reaches the top
          // or bottom edge of the viewport, in other words,
          // where |mouseY - centerY| == |centerY - topEdge (0)|
          if (Math.abs(delta_vt) >= 50) {
            var delta_vt_normalized = Math.abs(delta_vt) - 50;
            scroll_vt = (delta_vt_normalized / 50) * MAX_SCROLL_VT;
            scroll_vt = delta_vt > 0 ? scroll_vt : -scroll_vt;
          }

          clearInterval(scrollingInterval);

          if (Math.abs(scroll_vt) > 0.01) {
            // use scrolling vt velocity scroll_vt to
            // auto-scroll left-column from currentScrollTop
            // to newScrollTop = currentScrollTop + scroll_vt pixels
            // in 10 millis
            scrollingInterval = setInterval(function () {
              var currentScrollTop = leftColumn.scrollTop;
              var newScrollTop = currentScrollTop + scroll_vt;

              if (newScrollTop < 0) {
                newScrollTop = 0;
              } else {
                var maxScrollTop =
                  leftColumn.scrollHeight - leftColumn.clientHeight;
                if (newScrollTop > maxScrollTop) {
                  newScrollTop = maxScrollTop;
                }
              }

              // apply the change and
              // then wait for 10 millis
              leftColumn.scrollTop = newScrollTop;
            }, 10);
          }

          parallax_dh = centerX - mouseX;
          parallax_dv = -(dist_v + scroll_vt);

        }
        applyMotionParallax(parallax_dh, parallax_dv);
      }

      // calculates dh,dv parallax when
      // mouse wheel is moving
      // leftColumn_wheel_dh ==  leftColumn_mouse_dh
      // leftColumn_wheel_dv ==  leftColumn_mouse_dv
      // when mouse wheel is scrolling
      function handleLeftColumnWheel(wheelEvent) {
        const centerX = getLeftColumnHzCtr();
        const centerY = getLeftColumnVtCtr();
        const mouseX = wheelEvent.clientX;
        const mouseY = wheelEvent.clientY;

        const parallax_dh = centerX - mouseX;
        const parallax_dv = centerY - mouseY;

        applyMotionParallax(parallax_dh, parallax_dv);
      }

      function handleCardDivMouseEnter(event) {
        handleDivMouseEnter(event, "card-div");
      }
      function handleBizCardDivMouseEnter(event) {
        handleDivMouseEnter(event, "bizcard-div");
      }

      // handle mouse enter event for any div element with
      // cardClass "card-div" or "bizcard-div"
      function handleDivMouseEnter(event, cardClass) {
        var targetCardDiv = event.target.closest('.'+cardClass);
        if (targetCardDiv) {
          targetCardDiv.style.backgroundColor = targetCardDiv.getAttribute("saved-focus-background-color");
          targetCardDiv.style.color = targetCardDiv.getAttribute("saved-focus-color");
          if( cardClass == "card-div") {
            var z = CARD_MIN_Z;

            var filter_brightness_str = get_brightness_str_from_z(z);
            var filter_blur_str = get_blur_str_from_z(z);
            targetCardDiv.style.filter = `${filter_brightness_str} ${filter_blur_str}`;
          }
        }
      }

      function handleCardDivMouseLeave(event) {
        handleDivMouseLeave(event, "card-div");
      }
      function handleBizCardDivMouseLeave(event) {
        handleDivMouseLeave(event, "bizcard-div");
      }

      // handle mouse leave event for any div element with
      // cardClass "card-div" or "bizcard-div"
      function handleDivMouseLeave(event, cardClass) {
        var targetCardDiv = event.target.closest('.'+cardClass);
        if (targetCardDiv) {
          targetCardDiv.style.backgroundColor = targetCardDiv.getAttribute("saved-background-color");
          targetCardDiv.style.color = targetCardDiv.getAttribute("saved-color");
          if( cardClass == ".card-div") {
            var zIndexStr = targetCardDiv.style.zIndex;
            var z = get_z_from_zindexStr(zIndexStr);

            var filter_brightness_str = get_brightness_str_from_z(z);
            var filter_blur_str = get_blur_str_from_z(z);
            targetCardDiv.style.filter = `${filter_brightness_str} ${filter_blur_str}`;
          }
        }
      }

      function handleCardDivMouseClick(event) {
        handleCardMouseClick(event, "card-div");
      }
      function handleBizCardDivMouseClick(event) {
        handleCardMouseClick(event, "bizcard-div");
      }

      // handle mouse click event for any div element with
      // cardClass "card-div" or "bizcard-div"
      function handleCardMouseClick(event, cardClass) {
        var targetCardDiv = event.target.closest('.'+cardClass);
        if (targetCardDiv) {
          var card_div_line_item = document.createElement("li");
          card_div_line_item.className = "card-div-line-item";
          card_div_line_item.style.backgroundColor = targetCardDiv.getAttribute("saved-background-color");
          card_div_line_item.style.color = targetCardDiv.getAttribute("saved-color");
          card_div_line_item.innerHTML = targetCardDiv.innerText;
          var closeButton = document.createElement("button");
          closeButton.className = "card-div-line-item-button";
          closeButton.innerText = "x";
          closeButton.addEventListener("click", function () {
            card_div_line_item.remove();
          });
          card_div_line_item.appendChild(closeButton);
          rightColumnContent.appendChild(card_div_line_item);
        }
      }

      function renderAllCenterableDivsAtLeftColumnCenter() {
        const leftColumnCenter = getLeftColumnHzCtr();
        const centerableDivs = getAllCenterableDivs();
        for (const div of centerableDivs) {
          const divWidth = div.offsetWidth;
          const trans_dx = leftColumnCenter - divWidth / 2.0;
          const trans_dy = 0;
          const translateStr = `${trans_dx}px ${trans_dy}px`;
          div.style.translate = translateStr;
        }
        var canvasHeight = canvas.style.offsetHeight;
        var maxCanvasHeight = Math.max(leftColumn.scrollHeight, canvasHeight);
        console.log(maxCanvasHeight);
        //canvas.style.height = `${maxCanvasHeight}px`;
      }

      function positionGradients() {
        const canvasHeight = canvas.scrollHeight;
        const bottomGradientHeight = bottomGradient.offsetHeight;
        bottomGradient.style.top = `${canvasHeight - bottomGradientHeight}px`;
      }

      function handleWindowLoad() {
        createTimeline();
        createBizCardDivs();
        createCardDivs();
        renderAllCenterableDivsAtLeftColumnCenter();
        positionGradients();
      }

      function handleWindowResize() {
        // resize the left-column and the canvas since they don't do it themselves?
        var windowWidth = window.innerWidth;
        var leftColumnWidth = windowWidth / 2;

        document.getElementById("left-column").style.width =
          leftColumnWidth + "px";
        document.getElementById("canvas").style.width = leftColumnWidth + "px";

        renderAllCenterableDivsAtLeftColumnCenter();
        positionGradients();
      }

      // Attach event listeners
      window.addEventListener("load", handleWindowLoad);
      window.addEventListener("resize", handleWindowResize);
      leftColumn.addEventListener("mousemove", handleLeftColumnMouseMove);
      leftColumn.addEventListener("load", handleLeftColumnMouseMove);
      leftColumn.addEventListener("wheel", handleLeftColumnWheel, {
        passive: true,
      });
    </script>
  </body>
</html>
